From 60740fe384182a76384b666387be9d7457479785 Mon Sep 17 00:00:00 2001
From: Dhanavandhana Kannan <quic_dhanavan@quicinc.com>
Date: Fri, 22 Dec 2023 11:05:50 +0530
Subject: [PATCH] sigma_dut: Add support for multi-link BTM

Enable changes to support multi-link BTM
related test cases.

Sample CAPI command for adding neighbor:

sigma_dut -l ap_set_rfeature,NAME,QCM-AP1,Interface,24G,type,
EHT,Nebor_BSSID,"00:03:7f:12:97:97;00:03:7f:12:98:98",
Nebor_Op_Class,"81;128",Nebor_Op_Ch,"6;36",Nebor_Pref,255,
Nebor_MLD_address,00:03:7f:12:98:98,Nebor_MLD_LinkIDs,"0;1"

This command holds the neighbor information such as operating class,
operating channel, bssid, mld mac address and link id for each neighbor.
Added support to parse the neighbor info in mac80211_set_nebor()
function for atmost 16 links and it will be stored in the structure
btm_ap.

Sample CAPI command to send bss_tm_req frame:

sigma_dut -l dev_send_frame,NAME,QCM-AP1,Interface,24G,Program,EHT,
FrameName,BTMReq,Dest_MAC,00:03:7f:04:39:22,Cand_List,1

When the BTMReq command is sent, the stored neighbor info in the btm_ap
struct will be passed for every neighbor in the BSS Transition management
frame via bss_tm_req hostap_cli command.

If the neighbor links were specified in CAPI command, transition to one
of the mld links format for basic ML subelement in bss_tm_req command is
done.

c90a100008<MLD address><link id>

If the links were not specified in CAPI command, transition to
complete MLD format for basic ML subelement in bss_tm_req command is
done.

c909000007<MLD address>

Signed-off-by: Dhanavandhana Kannan <quic_dhanavan@quicinc.com>
---
 ap.c        | 214 ++++++++++++++++++++++++++++++++++++++--------------
 sigma_dut.h |  15 ++++
 2 files changed, 174 insertions(+), 55 deletions(-)

--- a/ap.c
+++ b/ap.c
@@ -11808,6 +11808,12 @@ static enum sigma_cmd_result cmd_ap_rese
 	dut->cohost_iface = 0;
 	dut->ap_cohosted_bss = VALUE_NOT_SET;
 	dut->ap_btmsupt = VALUE_NOT_SET;
+	dut->nebor_cnt = 0;
+	dut->btm_ml_link = 0;
+	for (int i = 0; i < NUM_NEIGHBORS; i++) {
+		for (int j = 0; j < MAX_MLD_LINKS; j++)
+			dut->btm[i].nebor_linkid[j] = -1;
+	}
 
 	if (dut->program == PROGRAM_HT || dut->program == PROGRAM_VHT ||
 	    dut->program == PROGRAM_HE || dut->program == PROGRAM_EHT) {
@@ -13327,8 +13333,23 @@ static int mac80211_ap_send_frame_btm_re
 	const char *val;
 	int i, cand_list = 0, bss_term = 0, self_ap_ne_pref = 0;
 	char nrbuf[dut->mbo_pref_ap_cnt + 1][100];
-	char nr_cmd_buf[200] = {0};
+	char nr_cmd_buf[250] = {0};
 	char bss_term_str[20] = {0};
+	int count = 0;
+	char nr[MAX_MLD_LINKS][100];
+	bool link_set = false;
+	char link_param[10];
+	int link_id = 0;
+
+	val = get_param(cmd, "Interface");
+	if (val) {
+		if (strcasecmp(val, "24G") == 0)
+			link_id = dut->band_to_link[0];
+		else if (strcasecmp(val, "5G") == 0)
+			link_id = dut->band_to_link[1];
+		else if (strcasecmp(val, "6G") == 0)
+			link_id = dut->band_to_link[2];
+	}
 
 	val = get_param(cmd, "Dest_MAC");
 	if (!val || parse_mac_address(dut, val, mac_addr) < 0) {
@@ -13349,57 +13370,140 @@ static int mac80211_ap_send_frame_btm_re
 		return -1;
 	}
 
-	val = get_param(cmd, "Cand_List");
-	if (val && val[0] && dut->mbo_pref_ap_cnt)
-		cand_list = atoi(val);
-
-	if (cand_list) {
-		self_mac = dut->mbo_self_ap_tuple.mac_addr;
-		self_ap_ne_pref = dut->mbo_self_ap_tuple.ap_ne_pref;
-		snprintf(nrbuf[0], sizeof(nrbuf[0]),
-			 "neighbor=%02x:%02x:%02x:%02x:%02x:%02x,0x00000017,%02d,%02d,%02d,0301%02x ",
-			 self_mac[0], self_mac[1], self_mac[2],
-			 self_mac[3], self_mac[4], self_mac[5],
-			 dut->mbo_self_ap_tuple.ap_ne_class,
-			 dut->mbo_self_ap_tuple.ap_ne_op_ch, 0,
-			 dut->ap_btmreq_disassoc_imnt ? 0 : self_ap_ne_pref);
-
-		for (i = 0; i < dut->mbo_pref_ap_cnt; i++) {
-			pref_mac_addr = dut->mbo_pref_aps[i].mac_addr;
-			snprintf(nrbuf[i + 1], sizeof(nrbuf[0]),
-				"neighbor=%02x:%02x:%02x:%02x:%02x:%02x,0x00000017,%02d,%02d,%02d,0301%02x ",
-				pref_mac_addr[0], pref_mac_addr[1], pref_mac_addr[2],
-				pref_mac_addr[3], pref_mac_addr[4], pref_mac_addr[5],
-				dut->mbo_pref_aps[i].ap_ne_class,
-				dut->mbo_pref_aps[i].ap_ne_op_ch, 0,
-				dut->mbo_pref_aps[i].ap_ne_pref);
-		}
+	if (dut->program == PROGRAM_EHT) {
+		snprintf(link_param, sizeof(link_param), "-l %d", link_id);
+		link_set = true;
 	}
 
-	for (i = 0; (i < dut->mbo_pref_ap_cnt + 1); i++)
-		strlcat(nr_cmd_buf, nrbuf[i], sizeof(nr_cmd_buf));
-
 	if (dut->ap_btmreq_term_bit && dut->ap_btmreq_bss_term_tsf) {
 		bss_term = 1;
 		snprintf(bss_term_str, sizeof(bss_term_str), "bss_term=%02d,%02d,",
-			 dut->ap_btmreq_bss_term_tsf, dut->ap_btmreq_bss_term_dur);
+			dut->ap_btmreq_bss_term_tsf, dut->ap_btmreq_bss_term_dur);
 	}
 
 	if (dut->ap_btmreq_disassoc_imnt)
 		dut->ap_assoc_delay = 1;
 
-	snprintf(buf, sizeof(buf),
-		 "-i %s bss_tm_req %02x:%02x:%02x:%02x:%02x:%02x pref=%d disassoc_imminent=%d disassoc_timer=%d %s %s mbo=0:%d:1",
-		 ifname, mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3],
-		 mac_addr[4], mac_addr[5], cand_list,
-		 dut->ap_btmreq_disassoc_imnt, disassoc_timer,
-		 bss_term ? bss_term_str : " ",
-		 cand_list ? nr_cmd_buf : " ", dut->ap_assoc_delay);
+	if (dut->nebor_cnt && dut->btm_ml_link) {
+		val = get_param(cmd, "Cand_List");
+		if (val)
+			cand_list = atoi(val);
 
-	sigma_dut_print(dut, DUT_MSG_INFO,"bss_tm_req buf %s\n", buf);
+		if (cand_list) {
+			for (int i = 0; i < dut->nebor_cnt; i++) {
+				if (dut->btm[i].nebor_linkid[0] != -1) {
+					for (int j = 0; j < dut->btm[i].num_of_bss; j++) {
+						/* If link is specified in CAPI command, transition
+						 * to one of the links for basic ML subelement and
+						 * created separate neighbor reports for each of the
+						 * links.
+						 */
+						snprintf(nr[count], sizeof(nr[0]),
+							"neighbor=%02x:%02x:%02x:%02x:%02x:%02x,0x0020ffff,%d,%d,%d,0301%02xc90a100008%02x%02x%02x%02x%02x%02x%02x ",
+							dut->btm[i].nebor_bssid[j][0],
+							dut->btm[i].nebor_bssid[j][1],
+							dut->btm[i].nebor_bssid[j][2],
+							dut->btm[i].nebor_bssid[j][3],
+							dut->btm[i].nebor_bssid[j][4],
+							dut->btm[i].nebor_bssid[j][5],
+							dut->btm[i].nebor_op_class[j],
+							dut->btm[i].nebor_op_ch[j], 0,
+							dut->btm[i].ap_ne_pref,
+							dut->btm[i].ap_mld_mac[0],
+							dut->btm[i].ap_mld_mac[1],
+							dut->btm[i].ap_mld_mac[2],
+							dut->btm[i].ap_mld_mac[3],
+							dut->btm[i].ap_mld_mac[4],
+							dut->btm[i].ap_mld_mac[5],
+							dut->btm[i].nebor_linkid[j]);
+						count = count + 1;
+					}
+				} else {
+					/* If the link id is not specified in the CAPI command,
+					 * transition to whole MLD for basic ML subelement.
+					 * Made default link id as 1 if link id is not specified
+					 * explicitly.
+					 */
+					snprintf(nr[count], sizeof(nr[0]),
+						"neighbor=%02x:%02x:%02x:%02x:%02x:%02x,0x0020ffff,%d,%d,%d,0301%02xc909000007%02x%02x%02x%02x%02x%02x ",
+						dut->btm[i].nebor_bssid[1][0],
+						dut->btm[i].nebor_bssid[1][1],
+						dut->btm[i].nebor_bssid[1][2],
+						dut->btm[i].nebor_bssid[1][3],
+						dut->btm[i].nebor_bssid[1][4],
+						dut->btm[i].nebor_bssid[1][5],
+						dut->btm[i].nebor_op_class[1],
+						dut->btm[i].nebor_op_ch[1], 0,
+						dut->btm[i].ap_ne_pref,
+						dut->btm[i].ap_mld_mac[0],
+						dut->btm[i].ap_mld_mac[1],
+						dut->btm[i].ap_mld_mac[2],
+						dut->btm[i].ap_mld_mac[3],
+						dut->btm[i].ap_mld_mac[4],
+						dut->btm[i].ap_mld_mac[5]);
+					count = count + 1;
+				}
+			}
+		}
+		for (i = 0; i < count; i++)
+			strlcat(nr_cmd_buf, nr[i], sizeof(nr_cmd_buf));
 
-	if (run_hostapd_cli(dut, buf) != 0)
-		return -1;
+		snprintf(buf, sizeof(buf),
+			"-i %s %s bss_tm_req %02x:%02x:%02x:%02x:%02x:%02x pref=%d disassoc_imminent=%d disassoc_timer=%d %s %s mbo=0:%d:1",
+			ifname, link_set ? link_param : "", mac_addr[0], mac_addr[1], mac_addr[2],
+			mac_addr[3], mac_addr[4], mac_addr[5], cand_list,
+			dut->ap_btmreq_disassoc_imnt, disassoc_timer,
+			bss_term ? bss_term_str : " ",
+			cand_list ? nr_cmd_buf : " ", dut->ap_assoc_delay);
+
+		sigma_dut_print(dut, DUT_MSG_INFO, "bss_tm_req buf %s\n", buf);
+		if (run_hostapd_cli(dut, buf) != 0)
+			return -1;
+
+	} else {
+		val = get_param(cmd, "Cand_List");
+		if (val && val[0] && dut->mbo_pref_ap_cnt)
+			cand_list = atoi(val);
+
+		if (cand_list) {
+			self_mac = dut->mbo_self_ap_tuple.mac_addr;
+			self_ap_ne_pref = dut->mbo_self_ap_tuple.ap_ne_pref;
+			snprintf(nrbuf[0], sizeof(nrbuf[0]),
+				"neighbor=%02x:%02x:%02x:%02x:%02x:%02x,0x00000017,%02d,%02d,%02d,0301%02x ",
+				self_mac[0], self_mac[1], self_mac[2],
+				self_mac[3], self_mac[4], self_mac[5],
+				dut->mbo_self_ap_tuple.ap_ne_class,
+				dut->mbo_self_ap_tuple.ap_ne_op_ch, 0,
+				dut->ap_btmreq_disassoc_imnt ? 0 : self_ap_ne_pref);
+
+			for (i = 0; i < dut->mbo_pref_ap_cnt; i++) {
+				pref_mac_addr = dut->mbo_pref_aps[i].mac_addr;
+				snprintf(nrbuf[i + 1], sizeof(nrbuf[0]),
+					"neighbor=%02x:%02x:%02x:%02x:%02x:%02x,0x00000017,%02d,%02d,%02d,0301%02x ",
+					pref_mac_addr[0], pref_mac_addr[1], pref_mac_addr[2],
+					pref_mac_addr[3], pref_mac_addr[4], pref_mac_addr[5],
+					dut->mbo_pref_aps[i].ap_ne_class,
+					dut->mbo_pref_aps[i].ap_ne_op_ch, 0,
+					dut->mbo_pref_aps[i].ap_ne_pref);
+			}
+		}
+
+		for (i = 0; (i < dut->mbo_pref_ap_cnt + 1); i++)
+			strlcat(nr_cmd_buf, nrbuf[i], sizeof(nr_cmd_buf));
+
+		snprintf(buf, sizeof(buf),
+			"-i %s bss_tm_req %02x:%02x:%02x:%02x:%02x:%02x pref=%d disassoc_imminent=%d disassoc_timer=%d %s %s mbo=0:%d:1",
+			ifname, mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3],
+			mac_addr[4], mac_addr[5], cand_list,
+			dut->ap_btmreq_disassoc_imnt, disassoc_timer,
+			bss_term ? bss_term_str : " ",
+			cand_list ? nr_cmd_buf : " ", dut->ap_assoc_delay);
+
+		sigma_dut_print(dut, DUT_MSG_INFO, "bss_tm_req buf %s\n", buf);
+
+		if (run_hostapd_cli(dut, buf) != 0)
+			return -1;
+	}
 
 	if (dut->ap_btmreq_term_bit) {
 		if (dut->ap_btmreq_bss_term_tsf >= 3)
@@ -13596,6 +13700,8 @@ enum sigma_cmd_result cmd_ap_send_frame(
 			return ap_send_frame_mbo(dut, conn, cmd);
 		if (strcasecmp(val, "60GHz") == 0)
 			return ap_send_frame_60g(dut, conn, cmd);
+		if (strcasecmp(val, "EHT") == 0)
+			return ap_send_frame_mbo(dut, conn, cmd);
 	}
 
 	val = get_param(cmd, "PMFFrameType");
@@ -16278,15 +16384,20 @@ static int mac80211_update_mbo_pref_ap_l
 static int mac80211_set_nebor(struct sigma_dut *dut, const char *ifname,
 			      struct sigma_cmd *cmd)
 {
-	unsigned char mac_addr[ETH_ALEN];
 	const char *val;
 	/*
 	 * -1 is invalid value for the following
 	 *  to differentiate between unset and set values
 	 *  -1 => implies not set by CAPI
 	 */
-	int ap_ne_class = -1, ap_ne_op_ch = -1, ap_ne_pref = -1;
 	int list_offset = dut->mbo_pref_ap_cnt;
+	int bssid_cnt = 0;
+	char *token, *subtoken;
+	char parser[200];
+	int neighbor_cnt = 0;
+	uint8_t self_mac[ETH_ALEN];
+
+	get_hwaddr(ifname, self_mac);
 
 	if (list_offset >= MBO_MAX_PREF_BSSIDS) {
 		sigma_dut_print(dut, DUT_MSG_ERROR,
@@ -16295,26 +16406,141 @@ static int mac80211_set_nebor(struct sig
 	}
 
 	val = get_param(cmd, "Nebor_Op_Class");
-	if (val)
-		ap_ne_class = atoi(val);
+	if (val) {
+		neighbor_cnt = dut->nebor_cnt;
+		if (neighbor_cnt > NUM_NEIGHBORS) {
+			sigma_dut_print(dut, DUT_MSG_ERROR,
+				  "Max neighbor support exceeded");
+			return -1;
+		}
+
+		if (strlen(val) > sizeof(parser)) {
+			sigma_dut_print(dut, DUT_MSG_ERROR,
+					"Input length (%zu) for Nebor_Op_Class is too large",
+					strlen(val));
+			return -1;
+		}
+
+		strlcpy(parser, val, sizeof(parser));
+		token = parser;
+		while ((subtoken = strtok_r(token, ";", &token))) {
+			if (bssid_cnt < MAX_MLD_LINKS)
+				dut->btm[neighbor_cnt].nebor_op_class[bssid_cnt] = atoi(subtoken);
+			else {
+				sigma_dut_print(dut, DUT_MSG_ERROR,
+					  "Max link support exceeded");
+				return -1;
+			}
+			bssid_cnt++;
+		}
+	}
 
 	val = get_param(cmd, "Nebor_Op_Ch");
-	if (val)
-		ap_ne_op_ch = atoi(val);
+	if (val) {
+		if (strlen(val) > sizeof(parser)) {
+			sigma_dut_print(dut, DUT_MSG_ERROR,
+					"Input length (%zu) for Nebor_Op_Ch is too large",
+					strlen(val));
+			return -1;
+		}
+
+		strlcpy(parser, val, sizeof(parser));
+		token = parser;
+		bssid_cnt = 0;
+		while ((subtoken = strtok_r(token, ";", &token))) {
+			if (bssid_cnt < MAX_MLD_LINKS)
+				dut->btm[neighbor_cnt].nebor_op_ch[bssid_cnt] = atoi(subtoken);
+			else {
+				sigma_dut_print(dut, DUT_MSG_ERROR,
+					  "Max link support exceeded");
+				return -1;
+			}
+			bssid_cnt++;
+		}
+	}
 
 	val = get_param(cmd, "Nebor_Pref");
 	if (val)
-		ap_ne_pref = atoi(val);
+		dut->btm[neighbor_cnt].ap_ne_pref = atoi(val);
 
 	val = get_param(cmd, "Nebor_BSSID");
-	if (!val || parse_mac_address(dut, val, mac_addr) < 0)
+	if (val) {
+		if (strlen(val) > sizeof(parser)) {
+			sigma_dut_print(dut, DUT_MSG_ERROR,
+					"Input length (%zu) for Nebor_BSSID is too large",
+					strlen(val));
+			return -1;
+		}
+
+		strlcpy(parser, val, sizeof(parser));
+		token = parser;
+		bssid_cnt = 0;
+		while ((subtoken = strtok_r(token, ";", &token))) {
+			if (bssid_cnt < MAX_MLD_LINKS) {
+				if (parse_mac_address(dut, subtoken,
+				    dut->btm[neighbor_cnt].nebor_bssid[bssid_cnt]) < 0) {
+					return -1;
+				}
+			} else {
+				sigma_dut_print(dut, DUT_MSG_ERROR,
+					  "Max link support exceeded");
+				return -1;
+			}
+			/* NOTE: Setting neighbor preference to 0 for self mac
+			 * address is needed only for EHT program and for MBO
+			 * program this is not needed */
+			if ((dut->program == PROGRAM_EHT) &&
+			    (memcmp(dut->btm[neighbor_cnt].nebor_bssid[bssid_cnt],
+				    self_mac, ETH_ALEN) == 0))
+				dut->btm[neighbor_cnt].ap_ne_pref = 0;
+			bssid_cnt++;
+		}
+	} else
 		return -1;
 
-	mbo_add_nebor_entry(dut, mac_addr, ap_ne_class, ap_ne_op_ch,
-			    ap_ne_pref);
+	val = get_param(cmd, "Nebor_MLD_address");
+	if (val) {
+		if (parse_mac_address(dut, val, dut->btm[neighbor_cnt].ap_mld_mac) < 0)
+			return -1;
+	}
 
-	if (mac80211_update_mbo_pref_ap_list(dut))
-		return -1;
+	val = get_param(cmd, "Nebor_MLD_LinkIDs");
+	if (val) {
+		if (strlen(val) > sizeof(parser)) {
+			sigma_dut_print(dut, DUT_MSG_ERROR,
+					"Input length (%zu) for Nebor_MLD_LinkIDs is too large",
+					strlen(val));
+			return -1;
+		}
+
+		strlcpy(parser, val, sizeof(parser));
+		token = parser;
+		bssid_cnt = 0;
+		while ((subtoken = strtok_r(token, ";", &token))) {
+			if (bssid_cnt < MAX_MLD_LINKS)
+				dut->btm[neighbor_cnt].nebor_linkid[bssid_cnt] =
+					atoi(subtoken);
+			else {
+				sigma_dut_print(dut, DUT_MSG_ERROR,
+						"Max link support exceeded");
+				return -1;
+			}
+			bssid_cnt++;
+		}
+	}
+
+	if (bssid_cnt > 1) {
+		dut->btm_ml_link = 1;
+		dut->btm[neighbor_cnt].num_of_bss = bssid_cnt;
+		dut->nebor_cnt = neighbor_cnt + 1;
+	} else {
+		mbo_add_nebor_entry(dut, dut->btm[neighbor_cnt].nebor_bssid[0],
+				dut->btm[neighbor_cnt].nebor_op_class[0],
+				dut->btm[neighbor_cnt].nebor_op_ch[0],
+				dut->btm[neighbor_cnt].ap_ne_pref);
+		if (mac80211_update_mbo_pref_ap_list(dut))
+			return -1;
+	}
 
 	return 0;
 }
--- a/sigma_dut.h
+++ b/sigma_dut.h
@@ -322,6 +322,9 @@ enum sec_ch_offset {
 	SEC_CH_40BELOW
 };
 
+#define MAX_MLD_LINKS 15
+#define NUM_NEIGHBORS 3
+
 struct mbo_pref_ap {
 	int ap_ne_class;
 	int ap_ne_op_ch;
@@ -329,6 +332,16 @@ struct mbo_pref_ap {
 	unsigned char mac_addr[ETH_ALEN];
 };
 
+struct btm_ap {
+	int nebor_op_class[MAX_MLD_LINKS];
+	int nebor_op_ch[MAX_MLD_LINKS];
+	int ap_ne_pref;
+	unsigned char nebor_bssid[MAX_MLD_LINKS][ETH_ALEN];
+	unsigned char ap_mld_mac[ETH_ALEN];
+	int nebor_linkid[MAX_MLD_LINKS];
+	int num_of_bss;
+};
+
 #ifdef NL80211_SUPPORT
 #define SOCK_BUF_SIZE (32 * 1024)
 struct nl80211_ctx {
@@ -1229,6 +1242,9 @@ struct sigma_dut {
 	int cohost_iface;
 	int ap_cohosted_bss;
 	enum value_not_set_enabled_disabled ap_btmsupt;
+	int nebor_cnt;
+	struct btm_ap btm[NUM_NEIGHBORS];
+	int btm_ml_link;
 };
 
 
