/*
 * Copyright (c) 2017, 2021, The Linux Foundation. All rights reserved.
 * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all copies.
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


/**
 * @defgroup fal_gen FAL_RSS_HASH
 * @{
 */
#ifndef _FAL_RSS_HASH_H_
#define _FAL_RSS_HASH_H_

#ifdef __cplusplus
extern "C" {
#endif                          /* __cplusplus */

#include "common/sw.h"
#include "fal/fal_type.h"

#define FAL_RSS_HASH_IP_MIX_MAX_NUM 4
#define FAL_RSS_HASH_FIN_MAX_NUM 5
typedef enum
{
	FAL_RSS_HASH_IPV4V6 = 0,
	FAL_RSS_HASH_IPV4ONLY = 1,
	FAL_RSS_HASH_IPV6ONLY = 2,
} fal_rss_hash_mode_t;

typedef struct
{
	a_uint32_t 	hash_mask; /* final hash value bits */
	a_bool_t	hash_fragment_mode; /* enable fragment mode or not */
	a_uint32_t	hash_seed; /* rss hash seed value */
	a_uint8_t	hash_sip_mix[FAL_RSS_HASH_IP_MIX_MAX_NUM]; /* source ip hash mix */
	a_uint8_t	hash_dip_mix[FAL_RSS_HASH_IP_MIX_MAX_NUM]; /* dest ip hash mix */
	a_uint8_t	hash_protocol_mix; /* L4 protocol hash mix */
	a_uint8_t	hash_sport_mix; /* L4 source port hash mix */
	a_uint8_t	hash_dport_mix; /* L4 dest port hash mix */
	a_uint8_t	hash_fin_inner[FAL_RSS_HASH_FIN_MAX_NUM]; /* hash fin inner mix */
	a_uint8_t	hash_fin_outer[FAL_RSS_HASH_FIN_MAX_NUM]; /* hash fin outer mix */
} fal_rss_hash_config_t;

enum {
	FUNC_RSS_HASH_CONFIG_SET = 0,
	FUNC_RSS_HASH_CONFIG_GET,
};

sw_error_t
fal_rss_hash_config_set(a_uint32_t dev_id, fal_rss_hash_mode_t mode, fal_rss_hash_config_t * config);

sw_error_t
fal_rss_hash_config_get(a_uint32_t dev_id, fal_rss_hash_mode_t mode, fal_rss_hash_config_t * config);

#define RSS_NO_HASH 0
#define RSS_5TUPLE_HASH 1
#define RSS_3TUPLE_HASH 2

#define TOEPLITZ_HASH_SECRET_KEY_NUM 11
#define TOEPLITZ_HASH_SECRET_KEY_BYTE_LEN (TOEPLITZ_HASH_SECRET_KEY_NUM * 4)
#define TOEPLITZ_HASH_CONFIG_NUM 12

typedef struct {
	a_uint32_t key[TOEPLITZ_HASH_SECRET_KEY_NUM];
} fal_toeplitz_secret_key_t;

typedef enum
{
	FAL_RSS_LEGACY_HASH = 0,
	FAL_RSS_TOEPLITZ_HASH,
	FAL_RSS_HASH_BUTT
} fal_rss_hash_algm_e;

typedef struct {
	fal_rss_hash_algm_e hash_algm;
	a_uint32_t extract_pos;	/* only valid for toeplitz */
} fal_rss_hash_algm_t;

typedef struct {
	/* for pkt property match, decide which stream the config will apply */
	a_uint8_t ip_ver_flg;
	a_uint8_t ip_frag_flg;
	a_uint8_t sec_flg;
	a_uint8_t ip_prot_flg;
	a_uint8_t ip_prot;
	a_uint8_t l4_port_flg;
	a_uint16_t l4_port;
	a_uint8_t l4_type_flg;

	/* for hash input data choose,
	  stream filed value will be addeed into hash input data when enable.
	*/
	a_bool_t sip_en;
	a_bool_t dip_en;
	a_bool_t sport_en;
	a_bool_t dport_en;
	a_bool_t spi_en;
	a_bool_t udf_0_en;
	a_bool_t udf_1_en;
	a_bool_t ip_prot_en;

	/* different with rss hash flag generated by stream,
	  toeplitz hash flag is generated by config.
	*/
	a_uint16_t hash_flag;
} fal_toeplitz_hash_config_t;

sw_error_t
fal_toeplitz_hash_secret_key_set(a_uint32_t dev_id, fal_toeplitz_secret_key_t *secret_key);
sw_error_t
fal_toeplitz_hash_secret_key_get(a_uint32_t dev_id, fal_toeplitz_secret_key_t *secret_key);

sw_error_t
fal_rsshash_algm_set(a_uint32_t dev_id, fal_rss_hash_algm_t *rsshash_algm);
sw_error_t
fal_rsshash_algm_get(a_uint32_t dev_id, fal_rss_hash_algm_t *rsshash_algm);

sw_error_t
fal_toeplitz_hash_config_add(a_uint32_t dev_id, fal_toeplitz_hash_config_t *toeplitz_cfg);
sw_error_t
fal_toeplitz_hash_config_del(a_uint32_t dev_id, fal_toeplitz_hash_config_t *toeplitz_cfg);
sw_error_t
fal_toeplitz_hash_config_getfirst(a_uint32_t dev_id, fal_toeplitz_hash_config_t *toeplitz_cfg);
sw_error_t
fal_toeplitz_hash_config_getnext(a_uint32_t dev_id, fal_toeplitz_hash_config_t *toeplitz_cfg);

#ifdef __cplusplus
}
#endif                          /* __cplusplus */
#endif                          /* _FAL_RSS_HASH_H_ */
/**
 * @}
 */

